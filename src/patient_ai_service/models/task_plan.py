"""
Task Plan Models - Agent-Generated Execution Plans

This module defines the task planning structures that agents use
to break down objectives into executable steps.

Key difference from old "plan" field:
- Plans were generated by reasoning engine BEFORE seeing tool results
- Task plans are generated by agents WITH full tool knowledge
- Tasks can adapt and replan based on execution results
"""

from datetime import datetime
from typing import Optional, Dict, Any, List
from pydantic import BaseModel, Field
from enum import Enum


class TaskStatus(str, Enum):
    """Status of a task in the execution plan."""
    
    PENDING = "pending"           # Not started yet
    IN_PROGRESS = "in_progress"   # Currently executing
    COMPLETE = "complete"         # Successfully finished
    BLOCKED = "blocked"           # Waiting for user input
    FAILED = "failed"             # Failed, cannot continue
    SKIPPED = "skipped"           # No longer needed (e.g., alternative path taken)
    CANCELLED = "cancelled"       # Explicitly cancelled


class TaskPriority(str, Enum):
    """Priority of a task."""
    CRITICAL = "critical"     # Must complete for objective
    HIGH = "high"             # Important but has alternatives
    NORMAL = "normal"         # Standard priority
    LOW = "low"               # Nice to have


class Task(BaseModel):
    """
    A single task in the execution plan.
    
    Tasks are atomic units of work that typically correspond to
    one tool call or one piece of information gathering.
    """
    
    # Identity
    id: str                              # Unique task ID (e.g., "task_1")
    description: str                     # Human-readable description
    
    # Tool mapping
    tool: Optional[str] = None           # Tool to call (e.g., "check_availability")
    params: Dict[str, Any] = Field(default_factory=dict)  # Tool parameters
    
    # Dependencies
    depends_on: List[str] = Field(default_factory=list)   # Task IDs this depends on
    
    # Status tracking
    status: TaskStatus = TaskStatus.PENDING
    priority: TaskPriority = TaskPriority.NORMAL
    
    # Results
    result: Optional[Dict[str, Any]] = None
    result_type: Optional[str] = None    # From ToolResultType
    
    # Blocking info (when status=BLOCKED)
    blocked_reason: Optional[str] = None
    blocked_options: Optional[List[Any]] = None
    blocked_suggested_response: Optional[str] = None
    
    # Failure info (when status=FAILED)
    failed_reason: Optional[str] = None
    retry_count: int = 0
    max_retries: int = 2
    
    # Timing
    created_at: datetime = Field(default_factory=datetime.utcnow)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    
    # Metadata
    iteration_created: int = 0
    iteration_completed: Optional[int] = None
    notes: Optional[str] = None
    
    def can_execute(self, completed_task_ids: List[str]) -> bool:
        """Check if this task can be executed (dependencies met)."""
        if self.status != TaskStatus.PENDING:
            return False
        
        # Check all dependencies are complete
        for dep_id in self.depends_on:
            if dep_id not in completed_task_ids:
                return False
        
        return True
    
    def mark_in_progress(self):
        """Mark task as in progress."""
        self.status = TaskStatus.IN_PROGRESS
        self.started_at = datetime.utcnow()
    
    def mark_complete(self, result: Dict[str, Any], iteration: int = None):
        """Mark task as complete with result."""
        self.status = TaskStatus.COMPLETE
        self.result = result
        self.result_type = result.get("result_type")
        self.completed_at = datetime.utcnow()
        if iteration:
            self.iteration_completed = iteration
    
    def mark_blocked(
        self,
        reason: str,
        options: List[Any] = None,
        suggested_response: str = None
    ):
        """Mark task as blocked pending user input."""
        self.status = TaskStatus.BLOCKED
        self.blocked_reason = reason
        self.blocked_options = options
        self.blocked_suggested_response = suggested_response
    
    def mark_failed(self, reason: str):
        """Mark task as failed."""
        self.status = TaskStatus.FAILED
        self.failed_reason = reason
        self.completed_at = datetime.utcnow()
    
    def can_retry(self) -> bool:
        """Check if task can be retried."""
        return self.retry_count < self.max_retries
    
    def retry(self):
        """Reset task for retry."""
        self.status = TaskStatus.PENDING
        self.retry_count += 1
        self.result = None
        self.failed_reason = None


class TaskPlan(BaseModel):
    """
    Complete task plan for achieving an objective.
    
    Generated by the agent on first iteration, then executed
    and adapted in subsequent iterations.
    """
    
    # Identity
    plan_id: str = Field(default_factory=lambda: f"plan_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}")
    
    # Objective from reasoning engine
    objective: str                       # What we're trying to achieve
    entities: Dict[str, Any] = Field(default_factory=dict)  # Entities involved
    constraints: List[str] = Field(default_factory=list)    # Constraints to respect
    
    # Tasks
    tasks: List[Task] = Field(default_factory=list)
    
    # Status
    status: str = "planning"             # "planning", "executing", "blocked", "complete", "failed"
    current_task_id: Optional[str] = None
    
    # Metrics
    total_tasks: int = 0
    completed_tasks: int = 0
    blocked_tasks: int = 0
    failed_tasks: int = 0
    
    # Timing
    created_at: datetime = Field(default_factory=datetime.utcnow)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    
    # Iteration tracking
    created_at_iteration: int = 0
    last_updated_iteration: int = 0
    
    def add_task(
        self,
        description: str,
        tool: str = None,
        params: Dict[str, Any] = None,
        depends_on: List[str] = None,
        priority: TaskPriority = TaskPriority.NORMAL
    ) -> Task:
        """Add a task to the plan."""
        task_id = f"task_{len(self.tasks) + 1}"
        
        task = Task(
            id=task_id,
            description=description,
            tool=tool,
            params=params or {},
            depends_on=depends_on or [],
            priority=priority,
            iteration_created=self.last_updated_iteration
        )
        
        self.tasks.append(task)
        self.total_tasks = len(self.tasks)
        
        return task
    
    def get_task(self, task_id: str) -> Optional[Task]:
        """Get task by ID."""
        for task in self.tasks:
            if task.id == task_id:
                return task
        return None
    
    def get_next_executable_task(self) -> Optional[Task]:
        """Get the next task that can be executed."""
        completed_ids = self.get_completed_task_ids()
        
        for task in self.tasks:
            if task.can_execute(completed_ids):
                return task
        
        return None
    
    def get_completed_task_ids(self) -> List[str]:
        """Get IDs of all completed tasks."""
        return [t.id for t in self.tasks if t.status == TaskStatus.COMPLETE]
    
    def get_blocked_tasks(self) -> List[Task]:
        """Get all blocked tasks."""
        return [t for t in self.tasks if t.status == TaskStatus.BLOCKED]
    
    def get_failed_tasks(self) -> List[Task]:
        """Get all failed tasks."""
        return [t for t in self.tasks if t.status == TaskStatus.FAILED]
    
    def get_pending_tasks(self) -> List[Task]:
        """Get all pending tasks."""
        return [t for t in self.tasks if t.status == TaskStatus.PENDING]
    
    def has_blocked_tasks(self) -> bool:
        """Check if any tasks are blocked."""
        return any(t.status == TaskStatus.BLOCKED for t in self.tasks)
    
    def all_tasks_complete(self) -> bool:
        """Check if all tasks are complete."""
        if not self.tasks:
            return False
        
        return all(
            t.status in [TaskStatus.COMPLETE, TaskStatus.SKIPPED]
            for t in self.tasks
        )
    
    def update_metrics(self):
        """Update task metrics."""
        self.total_tasks = len(self.tasks)
        self.completed_tasks = len([t for t in self.tasks if t.status == TaskStatus.COMPLETE])
        self.blocked_tasks = len([t for t in self.tasks if t.status == TaskStatus.BLOCKED])
        self.failed_tasks = len([t for t in self.tasks if t.status == TaskStatus.FAILED])
        
        # Update overall status
        if self.all_tasks_complete():
            self.status = "complete"
            self.completed_at = datetime.utcnow()
        elif self.blocked_tasks > 0:
            self.status = "blocked"
        elif self.failed_tasks > 0 and self.completed_tasks == 0:
            self.status = "failed"
        elif self.completed_tasks > 0:
            self.status = "executing"
    
    def get_status_display(self) -> str:
        """Get human-readable status display for prompts."""
        lines = []
        lines.append("═" * 60)
        lines.append(f"TASK PLAN: {self.objective}")
        lines.append("═" * 60)
        lines.append(f"Status: {self.status.upper()}")
        lines.append(f"Progress: {self.completed_tasks}/{self.total_tasks} tasks complete")
        lines.append("")
        
        for task in self.tasks:
            # Status icon
            icons = {
                TaskStatus.PENDING: "○",
                TaskStatus.IN_PROGRESS: "◐",
                TaskStatus.COMPLETE: "✓",
                TaskStatus.BLOCKED: "⏸",
                TaskStatus.FAILED: "✗",
                TaskStatus.SKIPPED: "⊘",
                TaskStatus.CANCELLED: "⊗"
            }
            icon = icons.get(task.status, "?")
            
            # Dependencies
            deps = f" [depends: {', '.join(task.depends_on)}]" if task.depends_on else ""
            
            lines.append(f"{icon} {task.id}: {task.description}{deps}")
            
            if task.status == TaskStatus.COMPLETE and task.result:
                result_preview = str(task.result)[:100]
                lines.append(f"   └─ Result: {result_preview}...")
            
            if task.status == TaskStatus.BLOCKED:
                lines.append(f"   └─ Blocked: {task.blocked_reason}")
                if task.blocked_options:
                    lines.append(f"   └─ Options: {task.blocked_options[:3]}")
            
            if task.status == TaskStatus.FAILED:
                lines.append(f"   └─ Failed: {task.failed_reason}")
        
        lines.append("")
        lines.append("═" * 60)
        
        return "\n".join(lines)
    
    def get_continuation_context(self) -> Dict[str, Any]:
        """Get context for continuation after blocking."""
        blocked = self.get_blocked_tasks()
        if not blocked:
            return {}
        
        first_blocked = blocked[0]
        return {
            "blocked_task_id": first_blocked.id,
            "blocked_reason": first_blocked.blocked_reason,
            "blocked_options": first_blocked.blocked_options,
            "suggested_response": first_blocked.blocked_suggested_response,
            "completed_tasks": self.get_completed_task_ids(),
            "plan_status": self.status
        }


# NOTE: TaskPlanGenerator class removed in Phase 6
# Agents now generate their own plans using the _plan() method with AgentPlan models
# See patient_ai_service.models.agent_plan for the new plan system

